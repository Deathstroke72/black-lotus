package orchestrator

import (
“context”
“fmt”
“os”
“path/filepath”
“strings”
“time”

```
"inventory-agents/agents"
"inventory-agents/config"
```

)

// Pipeline defines which agents run and in what order
type Pipeline struct {
agents []agents.Agent
cfg    *config.Config
}

// PipelineResult holds all outputs from a full pipeline run
type PipelineResult struct {
Results   []*agents.AgentResult
StartTime time.Time
EndTime   time.Time
Duration  time.Duration
}

// NewInventoryPipeline creates the full agent pipeline for the inventory microservice
func NewInventoryPipeline(cfg *config.Config) *Pipeline {
return &Pipeline{
cfg: cfg,
agents: []agents.Agent{
agents.NewAPIDesignAgent(cfg),
agents.NewBackendDBAgent(cfg),
agents.NewMessagingAgent(cfg),
agents.NewTestingSecurityAgent(cfg),
},
}
}

// Run executes all agents sequentially, passing each agent’s output as context to the next
func (p *Pipeline) Run(ctx context.Context, baseTask string) (*PipelineResult, error) {
result := &PipelineResult{StartTime: time.Now()}
agentContext := map[string]string{
“project_context”: baseTask,
}

```
contextKeys := []string{
	"api_design",
	"backend_db",
	"messaging",
	"testing_security",
}

fmt.Println("\n╔══════════════════════════════════════════════════╗")
fmt.Println("║    Inventory Microservice Agent Pipeline         ║")
fmt.Println("╚══════════════════════════════════════════════════╝\n")

for i, agent := range p.agents {
	fmt.Printf("▶ [%d/%d] Running: %s\n", i+1, len(p.agents), agent.Name())
	fmt.Printf("  %s\n\n", agent.(interface{ Description() string }).Description())

	agentResult, err := agent.Run(ctx, baseTask, agentContext)
	if err != nil {
		return nil, fmt.Errorf("agent %q failed: %w", agent.Name(), err)
	}

	// Store this agent's output as context for subsequent agents
	if i < len(contextKeys) {
		// Store a summary (first 3000 chars) to avoid context bloat
		summary := agentResult.Output
		if len(summary) > 3000 {
			summary = summary[:3000] + "\n... [truncated for context]"
		}
		agentContext[contextKeys[i]] = summary
	}

	result.Results = append(result.Results, agentResult)
	fmt.Printf("  ✓ %s complete — %d artifacts generated\n\n", agent.Name(), len(agentResult.Artifacts))
}

result.EndTime = time.Now()
result.Duration = result.EndTime.Sub(result.StartTime)
return result, nil
```

}

// SaveArtifacts writes all generated files to the output directory
func SaveArtifacts(result *PipelineResult, outputDir string) error {
if err := os.MkdirAll(outputDir, 0755); err != nil {
return err
}

```
summary := &strings.Builder{}
summary.WriteString("# Inventory Microservice — Generated by Agent Pipeline\n\n")
summary.WriteString(fmt.Sprintf("Generated at: %s\n", result.StartTime.Format(time.RFC1123)))
summary.WriteString(fmt.Sprintf("Total duration: %s\n\n", result.Duration.Round(time.Second)))

for _, agentResult := range result.Results {
	agentDir := filepath.Join(outputDir, sanitizeName(agentResult.AgentName))
	if err := os.MkdirAll(agentDir, 0755); err != nil {
		return err
	}

	// Write full agent output as markdown
	outputFile := filepath.Join(agentDir, "output.md")
	mdContent := fmt.Sprintf("# %s Output\n\n%s", agentResult.AgentName, agentResult.Output)
	if err := os.WriteFile(outputFile, []byte(mdContent), 0644); err != nil {
		return err
	}

	// Write individual code artifacts
	for j, artifact := range agentResult.Artifacts {
		filename := artifact.Filename
		if filename == "" {
			ext := extensionForLang(artifact.Language)
			filename = fmt.Sprintf("artifact_%d%s", j+1, ext)
		}
		artifactPath := filepath.Join(agentDir, filename)
		if err := os.WriteFile(artifactPath, []byte(artifact.Content), 0644); err != nil {
			return err
		}
	}

	summary.WriteString(fmt.Sprintf("## %s\n", agentResult.AgentName))
	summary.WriteString(fmt.Sprintf("- Artifacts: %d\n", len(agentResult.Artifacts)))
	for _, art := range agentResult.Artifacts {
		summary.WriteString(fmt.Sprintf("  - `%s` (%s)\n", art.Filename, art.Language))
	}
	summary.WriteString("\n")
}

// Write pipeline summary
return os.WriteFile(filepath.Join(outputDir, "README.md"), []byte(summary.String()), 0644)
```

}

func sanitizeName(name string) string {
return strings.ToLower(strings.ReplaceAll(strings.ReplaceAll(name, “ “, “_”), “&”, “and”))
}

func extensionForLang(lang string) string {
switch lang {
case “go”:
return “.go”
case “sql”:
return “.sql”
case “yaml”, “yml”:
return “.yaml”
case “json”:
return “.json”
default:
return “.txt”
}
}